/// <reference types="node" />
import { EventEmitter } from "events";
import { TeamSpeakQuery } from "./transport/TeamSpeakQuery";
import { QueryResponse } from "./types/QueryResponse";
import { ResponseError } from "./exception/ResponseError";
import { TeamSpeakClient } from "./node/Client";
import { TeamSpeakServer } from "./node/Server";
import { TeamSpeakChannel } from "./node/Channel";
import { TeamSpeakServerGroup } from "./node/ServerGroup";
import { TeamSpeakChannelGroup } from "./node/ChannelGroup";
import * as Response from "./types/ResponseTypes";
import * as Event from "./types/Events";
import * as Props from "./types/PropertyTypes";
import { QueryProtocol, ReasonIdentifier, TextMessageTargetMode, TokenType, LogLevel } from "./types/enum";
export * from "./types/enum";
export interface ConnectionParams {
    /** the host to connect to (default: 127.0.0.1) */
    host: string;
    /** the query protocol to use (default: @see QueryProtocol ) */
    protocol: QueryProtocol;
    /** the queryport to use (default: raw=10011 ssh=10022) */
    queryport: number;
    /** the server to select upon connect (default: none) */
    serverport?: number;
    /** the username to login with (default: none) */
    username?: string;
    /** the password to use with the login (default: none) */
    password?: string;
    /** the nickname to connect with */
    nickname?: string;
    /** time to wait until a timeout gets fired (default: 10000) */
    readyTimeout: number;
    /** wether a keepalive should get sent (default: true) */
    keepAlive: boolean;
    /** local address the socket should connect from */
    localAddress?: string;
    /** wether it should automatically connect after instanciating (default: true) */
    autoConnect?: boolean;
}
export interface TeamSpeak {
    on(event: "error", listener: (error: Error) => void): this;
    on(event: "ready", listener: () => void): this;
    on(event: "close", listener: (error?: Error) => void): this;
    on(event: "flooding", listener: (error: ResponseError) => void): this;
    on(event: "debug", listener: (event: Event.Debug) => void): this;
    on(event: "clientconnect", listener: (event: Event.ClientConnect) => void): this;
    on(event: "clientdisconnect", listener: (event: Event.ClientDisconnect) => void): this;
    on(event: "tokenused", listener: (event: Event.TokenUsed) => void): this;
    on(event: "textmessage", listener: (event: Event.TextMessage) => void): this;
    on(event: "clientmoved", listener: (event: Event.ClientMoved) => void): this;
    on(event: "serveredit", listener: (event: Event.ServerEdit) => void): this;
    on(event: "channeledit", listener: (event: Event.ChannelEdit) => void): this;
    on(event: "channelcreate", listener: (event: Event.ChannelCreate) => void): this;
    on(event: "channelmoved", listener: (event: Event.ChannelMove) => void): this;
    on(event: "channeldelete", listener: (event: Event.ChannelDelete) => void): this;
    channelClientPermList(cid: number, cldbid: number, permsid: false): Promise<Response.ChannelClientPermListId[]>;
    channelClientPermList(cid: number, cldbid: number, permsid: true): Promise<Response.ChannelClientPermListSid[]>;
}
export declare class TeamSpeak extends EventEmitter {
    readonly config: ConnectionParams;
    private clients;
    private servers;
    private servergroups;
    private channels;
    private channelgroups;
    private priorizeNextCommand;
    private query;
    private context;
    constructor(config: Partial<ConnectionParams>);
    /**
     * connects via a Promise wrapper
     * @param config config options to connect
     */
    static connect(config: Partial<ConnectionParams>): Promise<TeamSpeak>;
    /**
     * attempts a reconnect to the teamspeak server with full context features
     * @param attempts the amount of times it should try to reconnect (-1 = try forever)
     * @param timeout time in ms to wait inbetween reconnect
     */
    reconnect(attempts?: number, timeout?: number): Promise<this>;
    /**
     * waits a set time of ms
     * @param time time in ms to wait
     */
    static wait(time: number): Promise<unknown>;
    /**
     * connects to the TeamSpeak Server
     */
    connect(): Promise<TeamSpeak>;
    /** handles initial commands after successfully connecting to a TeamSpeak Server */
    private handleReady;
    /**
     * Gets called when a client connects to the TeamSpeak Server
     * @param event the raw teamspeak event
     */
    private evcliententerview;
    /**
     * Gets called when a client discconnects from the TeamSpeak Server
     * @param event the raw teamspeak event
     */
    private evclientleftview;
    /**
     * Gets called when a client uses a privilege key
     * @param event the raw teamspeak event
     */
    private evtokenused;
    /**
     * Gets called when a chat message gets received
     * @param event the raw teamspeak event
     */
    private evtextmessage;
    /**
     * Gets called when a client moves to a different channel
     * @param event the raw teamspeak event
     */
    private evclientmoved;
    /**
     * Gets called when the server has been edited
     * @param event the raw teamspeak event
     */
    private evserveredited;
    /**
     * Gets called when a channel gets edited
     * @param event the raw teamspeak event
     */
    private evchanneledited;
    /**
     * Gets called when a channel gets edited
     * @param event the raw teamspeak event
     */
    private evchannelcreated;
    /**
     * Gets called when a channel gets moved
     * @param event the raw teamspeak event
     */
    private evchannelmoved;
    /**
     * Gets called when a channel gets deleted
     * @param event the raw teamspeak event
     */
    private evchanneldeleted;
    /** priorizes the next command, this commands will be first in execution */
    priorize(): this;
    /**
     * Sends a raw command to the TeamSpeak Server.
     * @param {...any} args the command which should get executed on the teamspeak server
     * @example
     * ts3.execute("clientlist", ["-ip"])
     * ts3.execute("use", [9987], { client_nickname: "test" })
     */
    execute(cmd: string, ...args: TeamSpeakQuery.executeArgs[]): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Adds a new query client login, or enables query login for existing clients.
     * When no virtual server has been selected, the command will create global query logins.
     * Otherwise the command enables query login for existing client, and cldbid must be specified.
     * @param client_login_name the login name
     * @param cldbid the database id which should be used
     */
    queryLoginAdd(client_login_name: string, cldbid?: number): Promise<Response.QueryLoginAdd>;
    /**
     * Deletes an existing server query login on selected server.
     * When no virtual server has been selected, deletes global query logins instead.
     * @param cldbid deletes the querylogin of this client
     */
    queryLoginDel(cldbid: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * List existing query client logins.
     * The pattern parameter can include regular characters and SQL wildcard characters (e.g. %).
     * Only displays query logins of the selected virtual server, or all query logins when no virtual server have been  selected.
     * @param pattern the pattern to filter for client login names
     * @param start the offset from where clients should be listed
     * @param duration how many clients should be listed
     */
    queryLoginList(pattern?: string, start?: number, duration?: number): Promise<Response.QueryLoginList[]>;
    /**
     * Updates your own ServerQuery login credentials using a specified username.
     * The password will be auto-generated.
     * @param name
     */
    clientSetServerQueryLogin(name: string): Promise<Response.ClientSetServerQueryLogin>;
    /**
     * Change your ServerQuery clients settings using given properties.
     * @param props the properties which should be changed
     */
    clientUpdate(props: Props.ClientUpdate): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Subscribes to an Event
     * @param event the event on which should be subscribed
     * @param id the channel id, only required when subscribing to the "channel" event
     */
    registerEvent(event: string, id?: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Subscribes to an Event.
     */
    unregisterEvent(): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Authenticates with the TeamSpeak 3 Server instance using given ServerQuery login credentials.
     * @param username the username which you want to login with
     * @param password the password you want to login with
     */
    login(username: string, password: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /** Deselects the active virtual server and logs out from the server instance. */
    logout(): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /** Displays the servers version information including platform and build number. */
    version(): Promise<Response.Version>;
    /**
     * Displays detailed connection information about the server instance including uptime,
     * number of virtual servers online, traffic information, etc.
     */
    hostInfo(): Promise<Response.HostInfo>;
    /**
     * Displays the server instance configuration including database revision number,
     * the file transfer port, default group IDs, etc.
     */
    instanceInfo(): Promise<Response.InstanceInfo>;
    /**
     * Changes the server instance configuration using given properties.
     * @param properties the props you want to change
     */
    instanceEdit(properties: Props.InstanceEdit): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /** returns a list of IP addresses used by the server instance on multi-homed machines. */
    bindingList(): Promise<Response.BindingList[]>;
    /**
     * Selects the virtual server specified with the port to allow further interaction.
     * @param port the port the server runs on
     * @param client_nickname set nickname when selecting a server
     */
    useByPort(port: number, client_nickname?: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Selects the virtual server specified with the sid to allow further interaction.
     * @param sid the server id
     * @param client_nickname set nickname when selecting a server
     */
    useBySid(sid: number, client_nickname?: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /** returns information about your current ServerQuery connection including your loginname, etc. */
    whoami(): Promise<Response.Whoami>;
    /**
     * Displays detailed configuration information about the selected virtual server
     * including unique ID, number of clients online, configuration, etc.
     */
    serverInfo(): Promise<Response.ServerInfo>;
    /**
     * Displays the database ID of the virtual server running on the UDP port
     * @param virtualserver_port the server port where data should be retrieved
     */
    serverIdGetByPort(virtualserver_port: number): Promise<Response.ServerIdGetByPort>;
    /**
     * Changes the selected virtual servers configuration using given properties.
     * Note that this command accepts multiple properties which means that you're able to change all settings of the selected virtual server at once.
     */
    serverEdit(properties: Props.ServerEdit): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Stops the entire TeamSpeak 3 Server instance by shutting down the process.
     * @param reasonmsg specifies a text message that is sent to the clients before the client disconnects (requires TeamSpeak Server 3.2.0 or newer).
     */
    serverProcessStop(reasonmsg?: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * returns detailed connection information about the selected virtual server including uptime, traffic information, etc.
     */
    connectionInfo(): Promise<Response.ServerRequestConnectionInfo>;
    /**
     * Creates a new virtual server using the given properties and displays its ID, port and initial administrator privilege key.
     * If virtualserver_port is not specified, the server will test for the first unused UDP port
     * @param properties the server properties
     */
    serverCreate(properties: Props.ServerEdit): Promise<Response.ServerCreate>;
    /**
     * deletes the server
     * @param sid the server id to delete
     */
    serverDelete(sid: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Starts the virtual server. Depending on your permissions,
     * you're able to start either your own virtual server only or all virtual servers in the server instance.
     * @param sid the server id to start
     */
    serverStart(sid: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Stops the virtual server. Depending on your permissions,
     * you're able to stop either your own virtual server only or all virtual servers in the server instance.
     * @param sid the server id to stop
     * @param reasonmsg Specifies a text message that is sent to the clients before the client disconnects (requires TeamSpeak Server 3.2.0 or newer).
     */
    serverStop(sid: number, reasonmsg?: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Creates a new server group using the name specified with name.
     * The optional type parameter can be used to create ServerQuery groups and template groups.
     * @param name the name of the servergroup
     * @param type type of the servergroup
     */
    serverGroupCreate(name: string, type?: number): Promise<TeamSpeakServerGroup>;
    /**
     * returns the IDs of all clients currently residing in the server group.
     * @param sgid the servergroup id
     */
    serverGroupClientList(sgid: number): Promise<Response.ServerGroupClientList[]>;
    /**
     * Adds one or more clients to a server group specified with sgid.
     * Please note that a client cannot be added to default groups or template groups
     * @param cldbid one or more client database ids which should be added
     * @param sgid the servergroup id which the client(s) should be added to
     */
    serverGroupAddClient(cldbid: number | number[], sgid: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Removes one or more clients from the server group specified with sgid.
     * @param cldbid one or more client database ids which should be added
     * @param sgid the servergroup id which the client(s) should be removed from
     */
    serverGroupDelClient(cldbid: number | number[], sgid: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * displays all server groups the client specified with cldbid is currently residing in
     * @param cldbid the client database id to check
     */
    serverGroupsByClientId(cldbid: number): Promise<Response.ServerGroupsByClientId[]>;
    /**
     * Adds one or more servergroups to a client.
     * Please note that a client cannot be added to default groups or template groups
     * @param cldbid one or more client database ids which should be added
     * @param sgid one or more servergroup ids which the client should be added to
     */
    clientAddServerGroup(cldbid: number, sgid: number | number[]): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Removes one or more servergroups from the client.
     * @param cldbid one or more client database ids which should be added
     * @param sgid one or more servergroup ids which the client should be removed from
     */
    clientDelServerGroup(cldbid: number, sgid: number | number[]): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Deletes the server group. If force is set to 1, the server group will be deleted even if there are clients within.
     * @param sgid the servergroup id
     * @param force if set to 1 the servergoup will be deleted even when clients stil belong to this group
     */
    serverGroupDel(sgid: number, force?: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Creates a copy of the server group specified with ssgid.
     * If tsgid is set to 0, the server will create a new group.
     * To overwrite an existing group, simply set tsgid to the ID of a designated target group.
     * If a target group is set, the name parameter will be ignored.
     * @param ssgid the source ServerGroup
     * @param tsgid the target ServerGroup, 0 to create a new Group
     * @param type the type of the servergroup (0 = Query Group | 1 = Normal Group)
     * @param name name of the group
     */
    serverGroupCopy(ssgid: number, tsgid?: number, type?: number, name?: string): Promise<Response.ServerGroupCopy>;
    /**
     * Changes the name of the server group
     * @param sgid the servergroup id
     * @param name new name of the servergroup
     */
    serverGroupRename(sgid: number, name: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Displays a list of permissions assigned to the server group specified with sgid.
     * @param sgid the servergroup id
     * @param permsid if the permsid option is set to true the output will contain the permission names
     */
    serverGroupPermList(sgid: number, permsid?: boolean): Promise<Response.PermList[]>;
    /**
     * Adds a specified permissions to the server group. A permission can be specified by permid or permsid.
     * @param sgid the ServerGroup id
     * @param perm the permid or permsid
     * @param value value of the Permission
     * @param skip whether the skip flag should be set
     * @param negate whether the negate flag should be set
     */
    serverGroupAddPerm(sgid: number, perm: string | number, value: number, skip?: number, negate?: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Removes a set of specified permissions from the server group.
     * A permission can be specified by permid or permsid.
     * @param sgid the servergroup id
     * @param perm the permid or permsid
     */
    serverGroupDelPerm(sgid: number, perm: string | number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Sets a new temporary server password specified with pw. The temporary
     * password will be valid for the number of seconds specified with duration. The
     * client connecting with this password will automatically join the channel
     * specified with tcid. If tcid is set to 0, the client will join the default
     * channel.
     */
    serverTempPasswordAdd(props: Props.ServerTempPasswordAdd): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Deletes the temporary server password specified with pw.
     * @param pw the password to delete
     */
    serverTempPasswordDel(pw: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Returns a list of active temporary server passwords. The output contains the
     * clear-text password, the nickname and unique identifier of the creating
     * client.
     */
    serverTempPasswordList(): Promise<Response.ServerTempPasswordList[]>;
    /**
     * Creates a new channel using the given properties.
     * Note that this command accepts multiple properties which means that you're able to specifiy all settings of the new channel at once.
     * @param name the name of the channel
     * @param properties properties of the channel
     */
    channelCreate(name: string, properties?: Props.ChannelEdit): Promise<TeamSpeakChannel>;
    /**
     * Creates a new channel group using a given name.
     * The optional type parameter can be used to create ServerQuery groups and template groups.
     * @param name the name of the channelgroup
     * @param type type of the channelgroup
     */
    channelGroupCreate(name: string, type?: number): Promise<TeamSpeakChannelGroup>;
    /**
     * Retrieves a Single Channel by the given Channel ID
     * @param cid the channel id
     */
    getChannelByID(cid: number): Promise<TeamSpeakChannel | undefined>;
    /**
     * Retrieves a Single Channel by the given Channel Name
     * @param channel_name the name of the channel
     */
    getChannelByName(channel_name: string): Promise<TeamSpeakChannel | undefined>;
    /**
     * displays a list of channels matching a given name pattern
     * @param pattern the channel name pattern to search for
     */
    channelFind(pattern: string): Promise<Response.ChannelFind[]>;
    /**
     * Displays detailed configuration information about a channel including ID, topic, description, etc.
     * @param cid the channel id
     */
    channelInfo(cid: number): Promise<Response.ChannelInfo>;
    /**
     * Moves a channel to a new parent channel with the ID cpid.
     * If order is specified, the channel will be sorted right under the channel with the specified ID.
     * If order is set to 0, the channel will be sorted right below the new parent.
     * @param cid the channel id
     * @param cpid channel parent id
     * @param order channel sort order
     */
    channelMove(cid: number, cpid: number, order?: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Deletes an existing channel by ID.
     * If force is set to 1, the channel will be deleted even if there are clients within.
     * The clients will be kicked to the default channel with an appropriate reason message.
     * @param cid the channel id
     * @param force if set to 1 the channel will be deleted even when client are in it
     */
    channelDelete(cid: number, force?: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Changes a channels configuration using given properties.
     * Note that this command accepts multiple properties which means that you're able to change all settings of the channel specified with cid at once.
     * @param cid the channel id
     * @param properties the properties of the channel which should get changed
     */
    channelEdit(cid: number, properties?: Props.ChannelEdit): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Displays a list of permissions defined for a channel.
     * @param cid the channel id
     * @param permsid whether the permsid should be displayed aswell
     */
    channelPermList(cid: number, permsid?: boolean): Promise<Response.PermList[]>;
    /**
     * Adds a set of specified permissions to a channel.
     * @param cid the channel id
     * @param perm the permid or permsid
     * @param value the value which should be set
     */
    channelSetPerm(cid: number, perm: string | number, value: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Adds a set of specified permissions to a channel.
     * A permission can be specified by permid or permsid.
     * @param cid the channel id
     * @param permissions the permissions to assign
     * @example
     * TeamSpeak.channelSetPerms(5, [{ permsid: "i_channel_needed_modify_power", permvalue: 75 }])
     */
    channelSetPerms(cid: number, permissions: any[]): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Removes a set of specified permissions from a channel.
     * Multiple permissions can be removed at once.
     * A permission can be specified by permid or permsid.
     * @param cid the channel id
     * @param perm the permid or permsid
     */
    channelDelPerm(cid: number, perm: string | number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Retrieves a Single Client by the given Client ID
     * @param clid the client id
     */
    getClientByID(clid: number): Promise<TeamSpeakClient | undefined>;
    /**
     * Retrieves a Single Client by the given Client Database ID
     * @param client_database_id the client database Id
     */
    getClientByDBID(client_database_id: number): Promise<TeamSpeakClient | undefined>;
    /**
     * Retrieves a Single Client by the given Client Unique Identifier
     * @param client_unique_identifier the client unique identifier
     */
    getClientByUID(client_unique_identifier: string): Promise<TeamSpeakClient | undefined>;
    /**
     * Retrieves a Single Client by the given Client Unique Identifier
     * @param client_nickname the nickname of the client
     */
    getClientByName(client_nickname: string): Promise<TeamSpeakClient | undefined>;
    /**
     * Returns General Info of the Client, requires the Client to be online
     * @param clid one or more client ids to get
     */
    clientInfo(clid: number | number[]): Promise<Response.ClientInfo[]>;
    /**
     * Returns the Clients Database List
     * @param start start offset
     * @param duration amount of entries which should get retrieved
     * @param count retrieve the count of entries
     */
    clientDBList(start?: number, duration?: number, count?: boolean): Promise<Response.ClientDBList[]>;
    /**
     * Returns the Clients Database Info
     * @param cldbid one or more client database ids to get
     */
    clientDBInfo(cldbid: number | number[]): Promise<Response.ClientDBInfo[]>;
    /**
     * Kicks the Client from the Server
     * @param clid the client id
     * @param reasonid the reasonid
     * @param reasonmsg the message the client should receive when getting kicked
     */
    clientKick(clid: number, reasonid: ReasonIdentifier, reasonmsg: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Moves the Client to a different Channel
     * @param clid the client id
     * @param cid channel id in which the client should get moved
     * @param cpw the channel password
     */
    clientMove(clid: number, cid: number, cpw?: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Pokes the Client with a certain message
     * @param clid the client id
     * @param msg the message the client should receive
     */
    clientPoke(clid: number, msg: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Displays a list of permissions defined for a client
     * @param cldbid the client database id
     * @param permsid if the permsid option is set to true the output will contain the permission names
     */
    clientPermList(cldbid: number, permsid?: boolean): Promise<Response.PermList[]>;
    /**
     * Adds a set of specified permissions to a client.
     * Multiple permissions can be added by providing the three parameters of each permission.
     * A permission can be specified by permid or permsid.
     * @param cldbid the client database id
     * @param perm the permid or permsid
     * @param value value of the permission
     * @param skip whether the skip flag should be set
     * @param negate whether the negate flag should be set
     */
    clientAddPerm(cldbid: number, perm: string | number, value: number, skip?: number, negate?: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Removes a set of specified permissions from a client.
     * Multiple permissions can be removed at once.
     * A permission can be specified by permid or permsid
     * @param cldbid the client database id
     * @param perm the permid or permsid
     */
    clientDelPerm(cldbid: number, perm: string | number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Searches for custom client properties specified by ident and value.
     * The value parameter can include regular characters and SQL wildcard characters (e.g. %).
     * @param ident the key to search for
     * @param pattern the search pattern to use
     */
    customSearch(ident: string, pattern: string): Promise<Response.CustomSearch>;
    /**
     * returns a list of custom properties for the client specified with cldbid.
     * @param cldbid the Client Database ID which should be retrieved
     */
    customInfo(cldbid: number): Promise<Response.CustomInfo[]>;
    /**
     * Removes a custom property from a client specified by the cldbid.
     * This requires TeamSpeak Server Version 3.2.0 or newer.
     * @param cldbid the client Database ID which should be changed
     * @param ident the key which should be deleted
     */
    customDelete(cldbid: number, ident: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Creates or updates a custom property for client specified by the cldbid.
     * Ident and value can be any value, and are the key value pair of the custom property.
     * This requires TeamSpeak Server Version 3.2.0 or newer.
     * @param cldbid the client database id which should be changed
     * @param ident the key which should be set
     * @param value the value which should be set
     */
    customSet(cldbid: number, ident: string, value: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Sends a text message a specified target.
     * The type of the target is determined by targetmode while target specifies the ID of the recipient,
     * whether it be a virtual server, a channel or a client.
     * @param target target client id which should receive the message
     * @param targetmode targetmode (1: client, 2: channel, 3: server)
     * @param msg the message the client should receive
     */
    sendTextMessage(target: number, targetmode: TextMessageTargetMode, msg: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Retrieves a single ServerGroup by the given ServerGroup ID
     * @param sgid the servergroup id
     */
    getServerGroupByID(sgid: number): Promise<TeamSpeakServerGroup | undefined>;
    /**
     * Retrieves a single ServerGroup by the given ServerGroup Name
     * @param name the servergroup name
     */
    getServerGroupByName(name: string): Promise<TeamSpeakServerGroup | undefined>;
    /**
     * Retrieves a single ChannelGroup by the given ChannelGroup ID
     * @param cgid the channelgroup Id
     */
    getChannelGroupByID(cgid: number): Promise<TeamSpeakChannelGroup | undefined>;
    /**
     * Retrieves a single ChannelGroup by the given ChannelGroup Name
     * @param name the channelGroup name
     */
    getChannelGroupByName(name: string): Promise<TeamSpeakChannelGroup | undefined>;
    /**
     * Sets the channel group of a client
     * @param cgid the channelgroup which the client should get assigned
     * @param cid the channel in which the client should be assigned the group
     * @param cldbid the client database id which should be added to the group
     */
    setClientChannelGroup(cgid: number, cid: number, cldbid: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Deletes the channel group. If force is set to 1, the channel group will be deleted even if there are clients within.
     * @param cgid the channelgroup id
     * @param force if set to 1 the channelgroup will be deleted even when clients are in it
     */
    deleteChannelGroup(cgid: number, force?: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Creates a copy of the channel group.
     * If tcgid is set to 0, the server will create a new group.
     * To overwrite an existing group, simply set tcgid to the ID of a designated target group.
     * If a target group is set, the name parameter will be ignored.
     * @param scgid the source channelgroup
     * @param tcgid the target channelgroup (0 to create a new group)
     * @param type the type of the group (0 = Template Group | 1 = Normal Group)
     * @param name name of the goup
     */
    channelGroupCopy(scgid: number, tcgid?: number, type?: number, name?: string): Promise<Response.ChannelGroupCopy>;
    /**
     * Changes the name of the channel group
     * @param cgid the channelgroup id to rename
     * @param name new name of the ghannelgroup
     */
    channelGroupRename(cgid: number, name: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Displays a list of permissions assigned to the channel group specified with cgid.
     * @param cgid the channelgroup id to list
     * @param permsid if the permsid option is set to true the output will contain the permission names.
     */
    channelGroupPermList(cgid: number, permsid?: boolean): Promise<Response.PermList[]>;
    /**
     * Adds a specified permissions to the channel group. A permission can be specified by permid or permsid.
     * @param cgid the channelgroup id
     * @param perm the permid or permsid
     * @param value value of the permission
     * @param skip whether the skip flag should be set
     * @param negate whether the negate flag should be set
     */
    channelGroupAddPerm(cgid: number, perm: string | number, value: number, skip?: number, negate?: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Removes a set of specified permissions from the channel group. A permission can be specified by permid or permsid.
     * @param cgid the channelgroup id
     * @param perm the permid or permsid
     */
    channelGroupDelPerm(cgid: number, perm: string | number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Displays the IDs of all clients currently residing in the channel group.
     * @param cgid the channelgroup id
     * @param cid the channel id
     * @param cldbid the client database id to filter
     */
    channelGroupClientList(cgid: number, cid?: number, cldbid?: number): Promise<Response.ChannelGroupClientList[]>;
    /**
     * Displays all permissions assigned to a client for the channel specified with cid.
     * If permid is set to 0, all permissions will be displayed.
     * A permission can be specified by permid or permsid.
     * @param cldbid the client database id
     * @param cid one or more permission names
     * @param permid one or more permission ids
     * @param permsid one or more permission names
     */
    permOverview(cldbid: number, cid: number, perms?: number[] | string[]): Promise<Response.PermOverview[]>;
    /**
     * Retrieves a list of permissions available on the server instance including ID, name and description.
     */
    permissionList(): Promise<Response.PermissionList[]>;
    /**
     * Retrieves the database ID of one or more permissions specified by permsid.
     * @param permsid one name
     */
    permIdGetByName(permsid: string): Promise<Response.PermIdGetByName>;
    /**
     * Retrieves the database ID of one or more permissions specified by permsid.
     * @param permsid multiple permission names
     */
    permIdsGetByName(permsid: string[]): Promise<Response.PermIdGetByName[]>;
    /**
     * Retrieves the current value of the permission for your own connection.
     * This can be useful when you need to check your own privileges.
     * @param perm perm id or name which should be checked
     */
    permGet(perm: number | string): Promise<Response.PermGet>;
    /**
     * Retrieves detailed information about all assignments of the permission.
     * The output is similar to permoverview which includes the type and the ID of the client, channel or group associated with the permission.
     * @param perm perm id or name to retrieve
     */
    permFind(perm: number | string): Promise<Response.PermFind[]>;
    /**
     * Restores the default permission settings on the selected virtual server and creates a new initial administrator token.
     * Please note that in case of an error during the permreset call - e.g. when the database has been modified or corrupted - the virtual server will be deleted from the database.
     */
    permReset(): Promise<Response.Token>;
    /**
     * Retrieves a list of privilege keys available including their type and group IDs.
     */
    privilegeKeyList(): Promise<Response.PrivilegeKeyList[]>;
    /**
     * Create a new token.+
     * If type is set to 0, the ID specified with tokenid will be a server group ID.
     * Otherwise, tokenid is used as a channel group ID and you need to provide a valid channel ID using channelid.
     * @param tokentype token type
     * @param group depends on the type given, add either a valid channelgroup or servergroup
     * @param cid depends on the type given, add a valid channel id
     * @param description token description
     * @param customset token custom set
     */
    privilegeKeyAdd(tokentype: TokenType, group: number, cid?: number, description?: string, customset?: string): Promise<Response.Token>;
    /**
     * Create a new privilegekey token for a ServerGroup with the given description
     * @param group servergroup which should be generated the token for
     * @param description token description
     * @param tokencustomset token custom set
     */
    serverGroupPrivilegeKeyAdd(group: number, description?: string, tokencustomset?: string): Promise<Response.Token>;
    /**
     * Create a new privilegekey token for a Channel Group and assigned Channel ID with the given description
     * @param group the channel group for which the token should be valid
     * @param cid channel id for which the token should be valid
     * @param description token description
     * @param tokencustomset token custom set
     */
    channelGroupPrivilegeKeyAdd(group: number, cid: number, description?: string, tokencustomset?: string): Promise<Response.Token>;
    /**
     * Deletes an existing token matching the token key specified with token.
     * @param token the token which should be deleted
     */
    privilegeKeyDelete(token: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Use a token key gain access to a server or channel group.
     * Please note that the server will automatically delete the token after it has been used.
     * @param token the token which should be used
     */
    privilegeKeyUse(token: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Displays a list of offline messages you've received.
     * The output contains the senders unique identifier, the messages subject, etc.
     */
    messageList(): Promise<Response.MessageList[]>;
    /**
     * Sends an offline message to the client specified by uid.
     * @param cluid client unique identifier
     * @param subject subject of the message
     * @param message message text
     */
    messageAdd(cluid: string, subject: string, message: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Sends an offline message to the client specified by uid.
     * @param msgid the message id which should be deleted
     */
    messageDel(msgid: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Displays an existing offline message with the given id from the inbox.
     * @param msgid the message id
     */
    messageGet(msgid: number): Promise<Response.MessageGet>;
    /**
     * Displays an existing offline message with the given id from the inbox.
     * @param msgid the message id
     * @param flag if flag is set to 1 the message will be marked as read
     */
    messageUpdate(msgid: number, flag?: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Displays a list of complaints on the selected virtual server.
     * If dbid is specified, only complaints about the targeted client will be shown.
     * @param cldbid filter only for certain client with the given database id
     */
    complainList(cldbid?: number): Promise<Response.ComplainList[]>;
    /**
     * Submits a complaint about the client with database ID dbid to the server.
     * @param cldbid filter only for certain client with the given database id
     * @param message the Message which should be added
     */
    complainAdd(cldbid: number, message?: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Deletes the complaint about the client with ID tcldbid submitted by the client with ID fdbid from the server.
     * If fcldbid will be left empty all complaints for the tcldbid will be deleted
     * @param tcldbid the target client database id
     * @param fcldbid the client database id which filed the report
     */
    complainDel(tcldbid: number, fcldbid?: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Displays a list of active bans on the selected virtual server.
     * @param start optional start from where clients should be listed
     * @param duration optional duration on how much ban entries should be retrieved
     */
    banList(start?: number, duration?: number): Promise<Response.BanList[]>;
    /**
     * Adds a new ban rule on the selected virtual server.
     * All parameters are optional but at least one of the following must be set: ip, name, uid or mytsid.
     */
    ban(properties: Props.BanAdd): Promise<Response.BanAdd>;
    /**
     * Bans the client specified with ID clid from the server.
     * Please note that this will create two separate ban rules for the targeted clients IP address and his unique identifier.
     */
    banClient(properties: Props.BanClient): Promise<Response.BanAdd>;
    /**
     * Removes one or all bans from the server
     * @param banid the banid to remove, if not provided it will remove all bans
     */
    banDel(banid?: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Displays a specified number of entries from the servers log.
     * If instance is set to 1, the server will return lines from the master logfile (ts3server_0.log) instead of the selected virtual server logfile.
     * @param lines amount of lines to receive
     * @param reverse invert output (like Array.reverse)
     * @param instance instance or virtualserver log
     * @param begin_pos begin at position
     */
    logView(lines?: number, reverse?: number, instance?: number, begin_pos?: number): Promise<Response.LogView[]>;
    /**
     * Writes a custom entry into the servers log.
     * Depending on your permissions, you'll be able to add entries into the server instance log and/or your virtual servers log.
     * The loglevel parameter specifies the type of the entry
     * @param loglevel level 1 to 4
     * @param logmsg message to log
     */
    logAdd(loglevel: LogLevel, logmsg: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Sends a text message to all clients on all virtual servers in the TeamSpeak 3 Server instance.
     * @param msg message which will be sent to all instances
     */
    gm(msg: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * displays a list of clients matching a given name pattern
     * @param pattern the pattern to search clients
     */
    clientFind(pattern: string): Promise<Response.ClientFind[]>;
    /**
     * displays all client IDs matching the unique identifier specified by cluid
     * @param cluid the unique id to search for
     */
    clientGetIds(cluid: string): Promise<Response.ClientGetIds[]>;
    /**
     * displays the database ID matching the unique identifier specified by cluid
     * @param cluid the unique id to search for
     */
    clientGetDbidFromUid(cluid: string): Promise<Response.ClientGetDbidFromUid>;
    /**
     * displays the database ID and nickname matching the unique identifier specified by cluid
     * @param cluid the unique id to search for
     */
    clientGetNameFromUid(cluid: string): Promise<Response.ClientGetNameFromUid>;
    /**
     * displays the database ID and nickname matching the unique identifier specified by cluid
     * @param clid the client id to search from
     */
    clientGetUidFromClid(clid: number): Promise<Response.ClientGetUidFromClid>;
    /**
     * displays the unique identifier and nickname matching the database ID specified by cldbid
     * @param cldbid client database it to search from
     */
    clientGetNameFromDbid(cldbid: number): Promise<Response.ClientGetNameFromDbid>;
    /**
     * edits a specific client
     * @param clid the client id to modify
     * @param properties the properties to change
     */
    clientEdit(clid: number, properties: Props.ClientEdit): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Displays a list of client database IDs matching a given pattern.
     * You can either search for a clients last known nickname or his unique identity by using the -uid option.
     * @param pattern the pattern which should be searched for
     * @param isUid true when instead of the Name it should be searched for an uid
     */
    clientDBFind(pattern: string, isUid?: boolean): Promise<Response.ClientDBFind[]>;
    /**
     * Changes a clients settings using given properties.
     * @param cldbid the client database id which should be edited
     * @param properties the properties which should be modified
     */
    clientDBEdit(cldbid: number, properties: Props.ClientDBEdit): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Deletes a clients properties from the database.
     * @param cldbid the client database id which should be deleted
     */
    clientDBDelete(cldbid: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Displays a list of virtual servers including their ID, status, number of clients online, etc.
     */
    serverList(filter?: Partial<Response.ServerList>): Promise<TeamSpeakServer[]>;
    /**
     * Displays a list of channel groups available. Depending on your permissions, the output may also contain template groups.
     */
    channelGroupList(filter?: Partial<Response.ChannelGroupList>): Promise<TeamSpeakChannelGroup[]>;
    /**
     * Displays a list of server groups available.
     * Depending on your permissions, the output may also contain global ServerQuery groups and template groups.
     */
    serverGroupList(filter?: Partial<Response.ServerGroupList>): Promise<TeamSpeakServerGroup[]>;
    /**
     * Lists all Channels with a given Filter
     */
    channelList(filter?: Partial<Response.ChannelList>): Promise<TeamSpeakChannel[]>;
    /**
     * Lists all Clients with a given Filter
     */
    clientList(filter?: Partial<Response.ClientList>): Promise<TeamSpeakClient[]>;
    ftList(): Promise<Response.FTList[]>;
    /**
     * Displays a list of files and directories stored in the specified channels file repository.
     * @param cid the channel id to check for
     * @param path the path to list
     * @param cpw the channel password
     */
    ftGetFileList(cid: number, path?: string, cpw?: string): Promise<Response.FTGetFileList[]>;
    /**
     * Displays detailed information about one or more specified files stored in a channels file repository.
     * @param cid the channel id to check for
     * @param name the filepath to receive
     * @param cpw the channel password
     */
    ftGetFileInfo(cid: number, name: string, cpw?: string): Promise<Response.FTGetFileInfo>;
    /**
     * Stops the running file transfer with server-side ID serverftfid.
     * @param serverftfid server file transfer id
     * @param del
     */
    ftStop(serverftfid: number, del?: number): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Deletes one or more files stored in a channels file repository
     * @param cid the channel id to check for
     * @param name path to the file to delete
     * @param cpw the channel password
     */
    ftDeleteFile(cid: number, name: string, cpw?: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Creates new directory in a channels file repository
     * @param cid the channel id to check for
     * @param dirname path to the directory
     * @param cpw the channel password
     */
    ftCreateDir(cid: number, dirname: string, cpw?: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Renames a file in a channels file repository.
     * If the two parameters tcid and tcpw are specified, the file will be moved into another channels file repository
     * @param cid the channel id to check for
     * @param oldname the path to the file which should be renamed
     * @param newname the path to the file with the new name
     * @param tcid target channel id if the file should be moved to a different channel
     * @param cpw the channel password from where the file gets renamed
     * @param tcpw the channel password from where the file will get transferred to
     */
    ftRenameFile(cid: number, oldname: string, newname: string, tcid?: number, cpw?: string, tcpw?: string): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /**
     * Initializes a file transfer upload. clientftfid is an arbitrary ID to identify the file transfer on client-side.
     * On success, the server generates a new ftkey which is required to start uploading the file through TeamSpeak 3's file transfer interface.
     */
    ftInitUpload(transfer: Props.TransferUpload): Promise<Response.FTInitUpload>;
    /**
     * Initializes a file transfer download. clientftfid is an arbitrary ID to identify the file transfer on client-side.
     * On success, the server generates a new ftkey which is required to start downloading the file through TeamSpeak 3's file transfer interface.
     */
    ftInitDownload(transfer: Props.TransferDownload): Promise<Response.FTInitDownload>;
    /**
     * Uploads a file
     * @param path the path whith the filename where the file should be uploaded to
     * @param data the data to upload
     * @param cid channel id to upload to
     * @param cpw channel password of the channel which will be uploaded to
     */
    uploadFile(path: string, data: string | Buffer, cid?: number, cpw?: string): Promise<void>;
    /**
     * Returns the file in the channel with the given path
     * @param path the path whith the filename where the file should be uploaded to
     * @param cid channel id to download from
     * @param cpw channel password of the channel which will be uploaded to
     */
    downloadFile(path: string, cid?: number, cpw?: string): Promise<Buffer>;
    /**
     * Returns an Icon with the given Name
     * @param name the name of the icon to retrieve eg "icon_262672952"
     */
    downloadIcon(name: string): Promise<Buffer>;
    /**
     * Gets the Icon Name of a resolveable Perm List
     * @param permlist expects a promise which resolves to a permission list
     */
    getIconName(permlist: Promise<Response.PermList[]>): Promise<string>;
    /**
     * displays a snapshot of the selected virtual server containing all settings,
     * groups and known client identities. The data from a server snapshot can be
     * used to restore a virtual servers configuration, channels and permissions
     * using the serversnapshotdeploy command.
     * only supports version 2 (from server 3.10.0)
     * @param password the optional password to encrypt the snapshot
     */
    createSnapshot(password?: string): Promise<Response.SnapshotCreate>;
    /**
     * displays a snapshot of the selected virtual server containing all settings,
     * groups and known client identities. The data from a server snapshot can be
     * used to restore a virtual servers configuration, channels and permissions
     * using the serversnapshotdeploy command.
     * only supports version 2 (from server 3.10.0)
     * @param salt if a password has been set provide the salt from the response
     * @param password the password which has been set while saving
     * @param keepfiles wether it should keep the file mapping
     */
    deploySnapshot(data: string, salt?: string, password?: string, keepfiles?: boolean): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /** closes the ServerQuery connection to the TeamSpeak server instance. */
    quit(): Promise<import("./types/QueryResponse").QueryResponseTypes[]>;
    /** forcefully closes the socket connection */
    forceQuit(): void;
    /**
     * parses the whole cache by given objects
     * @param cache the cache object
     * @param list the list to check against the cache
     * @param key the key used to identify the object inside the cache
     * @param node the class which should be used
     */
    private handleCache;
    /**
     * updates the context when the inner callback gets called
     * and returns the first parameter
     * @param context context data to update
     */
    private updateContextResolve;
    /**
     * updates the context when the inner callback gets called
     * and throws the first parameter which is an error
     * @param context context data to update
     */
    private updateContextReject;
    /**
     * updates the context with new data
     * @param data the data to update the context with
     */
    private updateContext;
    /**
     * filters an array with given filter
     * @param array the array which should get filtered
     * @param filter filter object
     */
    static filter<T extends QueryResponse>(array: T[], filter: T): T[];
    /**
     * Transforms an Input to an Array
     * @param input input data which should be converted to an array
     */
    static toArray<T>(input: T | T[]): T[];
    /**
     * retrieves the first element of an array
     * @param input the response input
     */
    static singleResponse<T>(input: T | T[]): T;
}
